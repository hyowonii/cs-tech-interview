# TCP/IP

## TCP(Transmission Control Protocol)
- Transport layer(전송 계층)에서 사용하는 프로토콜
- IP와 함께 사용. IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리
- Reliable network 보장
- 연결형 서비스
- 흐름제어/혼잡제어 제공

#### 🚨 Reliable network를 보장한다는 것은 4가지 문제점이 존재
- 손실: packet이 손실될 수 있는 문제
- 순서 바뀜: packet의 순서가 바뀌는 문제
- Congestion: 네트워크가 혼잡한 문제
- Overload: receiver가 overload 되는 문제

#### 🔎 흐름제어/혼잡제어
- 흐름제어
  - Endpoint들 간의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것
  - 수신자가 데이터를 지나치게 많이 받지 않도록 조절하는 것
  - 기본 개념은 receiver가 sender에게 현재 자신의 상태를 feedback 한다는 것
- 혼잡제어
  - 송신 측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 방법

### 1. 흐름제어 (Flow Control)
- 수신 측이 송신 측보다 데이터 처리 속도가 빠르면 문제가 없지만, 송신 측이 더 빠를 경우 문제가 생김
- 수신 측에서 제한된 저장 용량을 초과하는 데이터는 손실 될 수 있으며, 만약 손실 된다면 불필요한 응답과 데이터 전송이 빈번히 발생
- 이러한 문제를 발생시키지 않기 위해 송신 측의 데이터 전송량을 수신 측에 따라 조절하는 기법
- **해결방법**
  - Stop and Wait: 매번 전송한 패킷에 대한 확인 응답을 받아야만 그 다음 패킷 전송하는 기법
  - Sliding Window: 수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법
    - 일정한 크기의 윈도우에 포함되는 모든 패킷을 전송하고, 패킷 전달 확인 응답을 받으면 응답 받은 개수만큼 윈도우를 옆으로 옮겨 그 다음 패킷들을 전송
    - 송신 윈도우를 수신 윈도우보다 작거나 같은 크기로 설정하면 흐름 제어 가능

### 2. 혼잡제어 (Congestion Control)
- 송신 측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달됨. 만약 한 라우터에 데이터가 몰릴 경우 모든 데이터를 처리하기가 힘듦 -> 오버플로우나 데이터 손실 발생
- 이러한 네트워크 혼잡을 피하기 위해 송신 측에서 보내는 데이터의 전송 속도를 강제로 줄이는 기법
- 네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 혼잡이라고 하며, 혼잡 현상을 방지/제거하는 기능이 혼잡제어
- 흐름제어가 송신 측과 수신 측 사이의 전송 속도를 다루는 것이라면, 혼잡제어는 호스트와 라우터를 포함한 보다 넓은 관점에서의 전송 문제를 다룸
- **해결방법**

  ![혼잡제어](https://t1.daumcdn.net/cfile/tistory/256E39425715F10103)
  - AIMD(Additive Increase / Multiplicative Decrease)
    - 처음에 패킷을 하나씩 보내고, 문제 없이 도착하면 window 크기를 1씩 증가시켜가면서 전송
    - 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷 보내는 속도를 절반으로 줄임
    - 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형상태로 수렴하게 되어 공평한 방식임
    - 문제점은, 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못함. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식
  - Slow Start
    - AIMD 방식과 마찬가지로 패킷을 하나씩 보내다가 window 크기를 1씩 늘림. 한 주기가 지나면 window 크기가 2배가 됨
    - 전송 속도는 지수 함수 꼴로 증가. 대신 혼잡 현상이 발생하면 window 크기를 1로 떨어뜨림
    - 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량 어느 정도 예상 가능
    - 그러므로 혼잡 현상이 발생했던 window 크기의 절반까지는 이전처럼 지수 함수 꼴로 window 크기를 증가시키고, 그 이후부터는 완만하게 1씩 증가시킴
  - Fast Retransmit
    - 패킷을 받는 쪽에서 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보냄
    - 순서대로 잘 도착한 마지막 패킷의 다음 패킷 순번을 ACK 패킷에 실어 보냄 -> 중간에 하나가 손실되게 되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 될 것이므로 이것을 감지한 순간 문제가 되는 순번의 패킷을 재전송 해줄 수 있음
    - 중복된 순번의 패킷을 3개 받으면 재전송 함. 약간 혼잡한 상황이 일어난 것을 감지했으므로 window 크기를 줄임
  - Fast Recovery
    - 혼잡 상태가 되면 window 크기를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방식
    - 이 정책까지 적용하면 혼잡 상황을 한번 겪고 난 후부터는 순수한 AIMD 방식으로 동작하게 됨


## 💡 TCP 3 & 4 way handshake
연결을 성립하고 해제하는 과정

### 1. 3 way handshake - 연결 성립
TCP는 정확한 전송을 보장해야 하므로 통신하기에 앞서 논리적인 접속을 성립하기 위해 3 way handshake 과정을 진행

![3-way-handshake](https://media.geeksforgeeks.org/wp-content/uploads/TCP-connection-1.png)

1. 클라이언트가 서버에서 SYN 패킷을 보냄 (sequence: x)
2. 서버가 SYN(x)를 받고, 받았다는 신호인 ACK과 SYN 패킷을 클라이언트로 보냄 (sequence: y, ACK: x+1)
3. 클라이언트는 응답으로 ACK(x+1)과 SYN(y) 패킷을 받고, ACK(y+1)을 서버로 보냄


### 2. 4 way handshake - 연결 해제
모든 통신이 끝났다면 연결 해제

![4-way-handshake](https://media.geeksforgeeks.org/wp-content/uploads/CN.png)

1. 클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보냄
2. 서버는 FIN을 받고, 확인했다는 ACK을 클라이언트에게 보냄
3. 데이터를 모두 보냈다면 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보냄
4. 클라이언트는 FIN을 받고, 확인했다는 ACK을 서버에게 보냄 (아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT을 통해 기다림)
- 서버는 ACK을 받은 이후 소켓 close, 클라이언트는 TIME_WAIT 시간이 끝나면 close

#### 참고
<https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html>