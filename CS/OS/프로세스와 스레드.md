# 프로세스 & 스레드

프로세스 : 프로그램을 메모리 상에서 실행 중인 작업

스레드 : 프로세스 안에서 실행되는 여러 흐름 단위

![프로세스&스레드](https://camo.githubusercontent.com/3dc4ad61f03160c310a855a4bd68a9f2a2c9a4c7/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393938383931343635433637433330363036)

## 💡 프로세스(Process)
컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램

### 개념
- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
- 동적인 개념으로는 실행된 프로그램을 의미

### 할당받는 시스템 자원의 예
  - CPU 시간
  - 운영되기 위해 필요한 주소 공간
  - Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역
    - Code : 코드 자체를 구성하는 메모리 영역 (프로그램 명령)
    - Data : 전역변수, 정적변수, 배열 등
      - 초기화 된 데이터 data 영역에 저장
      - 초기화 되지 않은 데이터는 bss 영역에 저장
    - Heap : 동적 할당 시 사용 (new(), malloc() 등)
    - Stack : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)
  ![메모리 영역](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/process.png)

### 특징
- 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가짐
- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근 불가능
- 한 프로세스가 다른 프로세스의 자원에 접근하려면, 프로세스 간의 통신(IPC, Inter-Process Communication) 사용 (ex. 파이프, 파일, 소켓 등을 이용한 통신 방법 이용)

### 프로세스의 주소 공간
_: 프로그램이 CPU에 의해 실행되면 -> 프로세스가 생성되고 메모리에 **프로세스 주소 공간**이 할당됨_

**Code, Data, Stack, Heap**
- Code Segment : 사용자가 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 공감. 컴파일 타임에 결정되고, 중간에 코드를 바꿀 수 없도록 **Read-Only**로 되어있음
- Data Segment : 전역 변수 또는 static 변수 등 프로그램이 사용하는 데이터를 저장하는 공간. 전역 변수가 변결될 수도 있어 **Read-Write**로 되어있음
- Stack Segment : 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터(지역변수, 매개변수, 리턴값 등)를 임시로 저장하는 공간. LIFO. 컴파일 시 stack 영역의 크기가 결정되므로 무한정 할당할 수 없음. 메모리를 초과하면 stack overflow 발생.
- Heap segment : 프로그래머가 필요할 때마다 사용하는 메모리 영역. 런타임에 결정됨.

_Q. 왜 Code 부분을 따로 두었나?_

_A. 프로그램의 코드는 프로그램이 컴파일 되고 나서는 바뀔 일이 없다(Read Only). 따라서 같은 프로그램을 실행시켜 몇 개의 프로세스가 실행되더라도 다 똑같은 코드 내용을 가지고 있는 것이기 때문에 Code 부분을 공유하여 메모리 사용량을 줄이는 목적이다._

_Q. 왜 Stack 부분과 Data 부분을 나누었나?_

_A. 함수 외부와 함수에 따라 Stack 구조 활용을 위해 나누어 둔 것이다. 전역 변수의 경우 어떤 함수에서도 접근할 수 있어야 하므로 Data 영역에 넣고, 함수의 경우 호출 시 Stack 영역에 넣었다가 종료 시 Stack 영역에서 빼는 식으로 사용된다._

<img width=300 src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2630833B58F1C0363A">

## 💡 스레드(Thread)
프로세스 내에서 실행되는 여러 흐름의 단위

### 개념
- 프로세스의 특정한 수행 경로
- 프로세스가 할당받은 자원을 이용하는 실행의 단위

### 특징
- 프로세스 내에서 각각 Stack만 따로 할당 받고, Code, Data, Heap 영역은 공유
- 각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있음
- 한 스레드가 프로세스 자원을 변경하면 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있음

_**프로세스는 자신만의 고유 공간과 자원을 할당받아 사용하는데 반해, 스레드는 다른 스레드와 공간 및 자원을 공유하면서 사용하는 차이가 존재**_
</br></br>

## 📍 멀티 프로세스 & 멀티 스레드

### **멀티 프로세스**
: 하나의 프로그램의 여러 개의 프로세스로 구성하여 각 프로세스가 병렬적으로 작업을 수행하는 것
- 장점 
  - 안정성 (메모리 침범 문제를 OS차원에서 해결)
- 단점
  - 각각 독립된 메모리 영역을 갖고 있어 작업량이 많을수록 오버헤드 발생. Context Switching으로 인한 성능 저하

_Context Switching?_

프로세스의 상태 정보를 저장하고 복원하는 일련의 과정

즉, 동작 중인 프로세스가 대기하면서 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태를 복구하는 과정

-> 프로세스는 각 독립된 메모리 영역을 할당받아 운영하므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을 때 오버헤드 발생 문제 존재

### **멀티 스레드**
: 하나의 응용 프로그램에서 여러 스레드가 각각 하나의 작업을 처리하는 것. 스레드들이 공유 메모리를 통해 다수의 작업을 동시에 처리하도록 함

- 장점
  - 독립적인 프로세스에 비해 공유 메모리만큼의 시간, 자원 손실 감소. 
  - 전역 변수와 정적 변수에 대한 자료 공유 가능
- 단점
  - 안정성 문제. 하나의 스레드가 데이터 공간을 망가뜨리면 모든 스레드가 작동 불가능 (공유 메모리)
  - 동기화 이슈로 인한 비정상적 동작 가능. 실행 순서 또는 메모리 접근 과정에서 생기는 문제


### 🚩 **멀티 프로세스 대신 멀티 스레드를 사용하는 이유**
![멀티 스레드](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/multi-thread.png)

1. 자원의 효율성 증대
- 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어듦 (프로세스 간의 Context Switching 시 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU 사이의 캐시 메모리에 대한 데이터까지 초기화되므로 오베헤드가 큼)
- 스레드 간 데이터를 주고 받는 것이 더 간단하고 따라서 시스템 자원 소모가 줄어듦

2. 처리 비용 감소 및 응답 시간 단축
- 프로세스 간 통신(IPC)보다 스레드 간의 통신의 비용이 적어 작업들 간의 통신 부담이 줄어듦
- 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 더 빠름

#### 참조
<https://gyoogle.dev/blog/computer-science/operating-system/Process%20vs%20Thread.html>

<https://gyoogle.dev/blog/computer-science/operating-system/Process%20Address%20Space.html>

<https://github.com/WeareSoft/tech-interview/blob/master/contents/os.md#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4>

<https://zangzangs.tistory.com/107>

<https://whereisusb.tistory.com/10>